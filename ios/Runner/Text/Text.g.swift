// //
// //  Text.g.swift
// //  Runner
// //
// //  Created by Koichi Kishimoto on 2024/10/20.
// //

// // Autogenerated from Pigeon (v22.5.0), do not edit directly.
// // See also: https://pub.dev/packages/pigeon

// import Foundation

// #if os(iOS)
//   import Flutter
// #elseif os(macOS)
//   import FlutterMacOS
// #else
//   #error("Unsupported platform.")
// #endif

// /// Error class for passing custom error details to Dart side.
// final class PigeonError: Error {
//   let code: String
//   let message: String?
//   let details: Any?

//   init(code: String, message: String?, details: Any?) {
//     self.code = code
//     self.message = message
//     self.details = details
//   }

//   var localizedDescription: String {
//     return
//       "PigeonError(code: \(code), message: \(message ?? "<nil>"), details: \(details ?? "<nil>")"
//       }
// }

// private func wrapResult(_ result: Any?) -> [Any?] {
//   return [result]
// }

// private func wrapError(_ error: Any) -> [Any?] {
//   if let pigeonError = error as? PigeonError {
//     return [
//       pigeonError.code,
//       pigeonError.message,
//       pigeonError.details,
//     ]
//   }
//   if let flutterError = error as? FlutterError {
//     return [
//       flutterError.code,
//       flutterError.message,
//       flutterError.details,
//     ]
//   }
//   return [
//     "\(error)",
//     "\(type(of: error))",
//     "Stacktrace: \(Thread.callStackSymbols)",
//   ]
// }

// private func createConnectionError(withChannelName channelName: String) -> PigeonError {
//   return PigeonError(code: "channel-error", message: "Unable to establish connection on channel: '\(channelName)'.", details: "")
// }

// private func isNullish(_ value: Any?) -> Bool {
//   return value is NSNull || value == nil
// }

// private func nilOrValue<T>(_ value: Any?) -> T? {
//   if value is NSNull { return nil }
//   return value as! T?
// }

// private class TextPigeonCodecReader: FlutterStandardReader {
// }

// private class TextPigeonCodecWriter: FlutterStandardWriter {
// }

// private class TextPigeonCodecReaderWriter: FlutterStandardReaderWriter {
//   override func reader(with data: Data) -> FlutterStandardReader {
//     return TextPigeonCodecReader(data: data)
//   }

//   override func writer(with data: NSMutableData) -> FlutterStandardWriter {
//     return TextPigeonCodecWriter(data: data)
//   }
// }

// class TextPigeonCodec: FlutterStandardMessageCodec, @unchecked Sendable {
//   static let shared = TextPigeonCodec(readerWriter: TextPigeonCodecReaderWriter())
// }

// /// Generated protocol from Pigeon that represents a handler of messages from Flutter.
// protocol NativeTextApi {
//   func setText(text: String) throws
// }

// /// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
// class NativeTextApiSetup {
//   static var codec: FlutterStandardMessageCodec { TextPigeonCodec.shared }
//   /// Sets up an instance of `NativeTextApi` to handle messages through the `binaryMessenger`.
//   static func setUp(binaryMessenger: FlutterBinaryMessenger, api: NativeTextApi?, messageChannelSuffix: String = "") {
//     let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
//     let setTextChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pigeon_multi_instance_demo.NativeTextApi.setText\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
//     if let api = api {
//       setTextChannel.setMessageHandler { message, reply in
//         let args = message as! [Any?]
//         let textArg = args[0] as! String
//         do {
//           try api.setText(text: textArg)
//           reply(wrapResult(nil))
//         } catch {
//           reply(wrapError(error))
//         }
//       }
//     } else {
//       setTextChannel.setMessageHandler(nil)
//     }
//   }
// }
// /// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
// protocol FlutterTextApiHandlerProtocol {
//   func textChanged(text textArg: String, completion: @escaping (Result<Void, PigeonError>) -> Void)
// }
// class FlutterTextApiHandler: FlutterTextApiHandlerProtocol {
//   private let binaryMessenger: FlutterBinaryMessenger
//   private let messageChannelSuffix: String
//   init(binaryMessenger: FlutterBinaryMessenger, messageChannelSuffix: String = "") {
//     self.binaryMessenger = binaryMessenger
//     self.messageChannelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
//   }
//   var codec: TextPigeonCodec {
//     return TextPigeonCodec.shared
//   }
//   func textChanged(text textArg: String, completion: @escaping (Result<Void, PigeonError>) -> Void) {
//     let channelName: String = "dev.flutter.pigeon.pigeon_multi_instance_demo.FlutterTextApiHandler.textChanged\(messageChannelSuffix)"
//     let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
//     channel.sendMessage([textArg] as [Any?]) { response in
//       guard let listResponse = response as? [Any?] else {
//         completion(.failure(createConnectionError(withChannelName: channelName)))
//         return
//       }
//       if listResponse.count > 1 {
//         let code: String = listResponse[0] as! String
//         let message: String? = nilOrValue(listResponse[1])
//         let details: String? = nilOrValue(listResponse[2])
//         completion(.failure(PigeonError(code: code, message: message, details: details)))
//       } else {
//         completion(.success(Void()))
//       }
//     }
//   }
// }
